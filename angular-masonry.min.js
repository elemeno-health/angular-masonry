/**
 * angular-masonry
 *
 * @external 'angular.module'
 * @version 0.16.0
 * @author {@link https://passy.me/|Pascal Hartig}
 * @license: MIT
 */
!function(){"use strict";const a=require("masonry-layout");angular.module("wu.masonry",[]).controller("MasonryCtrl",["$scope","$element","$timeout",function(a,b,c){function d(a){a.addClass("loaded")}var e={},f=[],g=!1,h=this,i=null;this.preserveOrder=!1,this.loadImages=!1,this.scheduleMasonryOnce=function(){var a=arguments,b=f.filter(function(b){return b[0]===a[0]}).length>0;b||this.scheduleMasonry.apply(null,arguments)},
// Make sure it's only executed once within a reasonable time-frame in
// case multiple elements are removed or added at once.
this.scheduleMasonry=function(){i&&c.cancel(i),f.push([].slice.call(arguments)),i=c(function(){g||(f.forEach(function(a){var b=a[0];a=a.slice(1),console.log("calling masonry",a),h.masonry[b].apply(h.masonry,a)}),f=[])},30)},this.addBrick=function(a,b,c){function f(){0===Object.keys(e).length&&h.masonry.resize(),void 0===e[c]&&(
// Keep track of added elements.
e[c]=!0,d(b),h.masonry[a](b,!0))}function i(){
// I wanted to make this dynamic but ran into huuuge memory leaks
// that I couldn't fix. If you know how to dynamically add a
// callback so one could say <masonry loaded="callback($element)">
// please submit a pull request!
console.log("masonry scheduled: _layout"),h.scheduleMasonryOnce("layout")}g||(h.loadImages?h.preserveOrder?(f(),window.imagesLoaded(b,i)):window.imagesLoaded(b,function(){f(),i()}):(f(),i()))},this.removeBrick=function(a,b){g||(delete e[a],h.masonry.remove(b),console.log("masonry scheduled: removeBrick"),this.scheduleMasonryOnce("layout"))},this.destroy=function(){g=!0,b.data("masonry")&&
// Gently uninitialize if still present
h.masonry.destroy(),a.$emit("masonry.destroyed"),e={}},this.reload=function(){h.masonry.reloadItems(),a.$emit("masonry.reloaded")}}]).directive("masonry",function(){return{restrict:"AE",controller:"MasonryCtrl",controllerAs:"msnry",link:{pre:function(b,c,d,e){var f=b.$eval(d.masonry||d.masonryOptions),g=angular.extend({itemSelector:d.itemSelector||".masonry-brick",columnWidth:parseInt(d.columnWidth,10)||d.columnWidth},f||{});b.masonryContainer=c[0],e.masonry=new a(b.masonryContainer,g);var h=b.$eval(d.loadImages);e.loadImages=!!h;var i=b.$eval(d.preserveOrder);e.preserveOrder=i!==!1&&void 0!==d.preserveOrder;var j=b.$eval(d.reloadOnShow);j!==!1&&void 0!==d.reloadOnShow&&b.$watch(function(){return c.prop("offsetParent")},function(a,b){a&&!b&&e.reload()});var k=b.$eval(d.reloadOnResize);k!==!1&&void 0!==d.reloadOnResize&&b.$watch("masonryContainer.offsetWidth",function(a,b){a!==b&&e.reload()}),b.$on("$destroy",e.destroy)}}}}).directive("masonryBrick",function(){return{restrict:"AC",require:"^masonry",scope:!0,link:{pre:function(a,b,c,d){var e,f=a.$id,g=a.$eval(c.prepend),h=g?"prepended":"appended";d.addBrick(h,b,f),b.on("$destroy",function(){d.removeBrick(f,b)}),a.$on("masonry.reload",function(){console.log("masonry scheduled: on masonry.reload"),d.scheduleMasonryOnce("reloadItems"),d.scheduleMasonryOnce("layout")}),a.$watch("$index",function(){void 0!==e&&e!==a.$index&&(console.log("masonry scheduled: on $index watch"),d.scheduleMasonryOnce("reloadItems"),d.scheduleMasonryOnce("layout")),e=a.$index})}}}})}();